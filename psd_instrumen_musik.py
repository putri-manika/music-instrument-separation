# -*- coding: utf-8 -*-
"""PSD_Instrumen Musik

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cJp6KPC40eO2LUlVpKcfmkfzS2rKhNFn

# **Akuisisi Data**

# **Visualisasi Sinyal**
"""

from IPython.display import Audio

# Path ke file audio
file_path = '/content/falling.mp3'

# Memutar audio
Audio(file_path)

"""### Domain Waktu"""

# Import dan tampilkan sinyal tersebut di sini

import numpy as np
import matplotlib.pyplot as plt
import librosa

# Mengambil data dari file audio
filename = '/content/falling.mp3'
audio_signal, sr = librosa.load(filename, sr=None)

# Tampilkan sinyal
plt.figure(figsize=(12, 6))
plt.plot(audio_signal)
plt.title('Sinyal Audio dari Instrumen Musik')
plt.xlabel('Sampel')
plt.ylabel('Amplitudo')
plt.grid()
plt.show()

"""### Domain Frekuensi"""

# Transformasikan sinyal tersebut ke dalam domain frekuensi
# Gunakan modul scipy.fft
from scipy.fft import fft

# Transformasi Fourier
N = len(audio_signal)
yf = fft(audio_signal)
xf = np.fft.fftfreq(N, 1 / sr)

# Tampilkan spektrum frekuensi
plt.figure(figsize=(12, 6))
plt.plot(xf[:N // 2], 2.0 / N * np.abs(yf[:N // 2]))
plt.title('Spektrum Frekuensi Sinyal Audio')
plt.xlabel('Frekuensi (Hz)')
plt.ylabel('Amplitudo')
plt.grid()
plt.show()

"""# **Pra-Pemrosesan**

### Filtering
"""

import numpy as np
import scipy.signal as signal
import scipy.io.wavfile as wav
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft, fftfreq
import soundfile as sf

# Fungsi untuk menerapkan filter
def apply_filter(audio, sr, filter_type, cutoff):
    nyquist = sr / 2
    normalized_cutoff = cutoff / nyquist

    if filter_type == "lowpass":
        b, a = signal.butter(4, normalized_cutoff, btype="low")
    elif filter_type == "highpass":
        b, a = signal.butter(4, normalized_cutoff, btype="high")
    else:
        raise ValueError("Filter type harus 'lowpass' atau 'highpass'.")

    filtered_audio = signal.filtfilt(b, a, audio)
    return filtered_audio

# Baca file audio
input_file = "falling.mp3"
audio, sr = sf.read(input_file)

# Pastikan audio mono
if len(audio.shape) > 1:
    audio = np.mean(audio, axis=1)

# Pisahkan Bass dan Biola
bass_audio = apply_filter(audio, sr, filter_type="lowpass", cutoff=400)  # Low-pass untuk bass
violin_audio = apply_filter(audio, sr, filter_type="highpass", cutoff=2000)  # High-pass untuk biola

# Simpan hasil
sf.write("bass_separated.wav", bass_audio, sr)
sf.write("violin_separated.wav", violin_audio, sr)

print("Hasil telah berhasil di simpan")

# Visualisasi hasil dari filtering
time = np.linspace(0, len(audio) / sr, num=len(audio))

plt.figure(figsize=(12, 8))
plt.subplot(3, 1, 1)
plt.plot(time, audio, label="Campuran (Bass + Biola)")
plt.legend()
plt.title("Campuran (Bass + Biola)")

plt.subplot(3, 1, 2)
plt.plot(time, bass_audio, label="Bass (Low-pass Filter)", color="r")
plt.legend()
plt.title("Bass")

plt.subplot(3, 1, 3)
plt.plot(time, violin_audio, label="Biola (High-pass Filter)", color="g")
plt.legend()
plt.title("Biola")

plt.tight_layout()
plt.show()

from IPython.display import Audio, display

# Path ke file audio
file_path_1 = 'bass_separated.wav'
file_path_2 = 'violin_separated.wav'
# Membuat objek Audio untuk masing-masing file
audio_1 = Audio(file_path_1)
audio_2 = Audio(file_path_2)

# Menampilkan pemutar audio untuk kedua file
display(audio_1)
display(audio_2)

"""### Normalisasi"""

import numpy as np
import scipy.signal as signal
import scipy.io.wavfile as wav
import matplotlib.pyplot as plt
from scipy.fft import fft, ifft, fftfreq
import soundfile as sf

# Fungsi untuk menerapkan filter
def apply_filter(audio, sr, filter_type, cutoff):
    nyquist = sr / 2
    normalized_cutoff = cutoff / nyquist

    if filter_type == "lowpass":
        b, a = signal.butter(4, normalized_cutoff, btype="low")
    elif filter_type == "highpass":
        b, a = signal.butter(4, normalized_cutoff, btype="high")
    else:
        raise ValueError("Filter type harus 'lowpass' atau 'highpass'.")

    filtered_audio = signal.filtfilt(b, a, audio)
    return filtered_audio

# Fungsi untuk normalisasi
def normalize_audio(audio):
    max_amplitude = np.max(np.abs(audio))
    normalized_audio = audio / max_amplitude
    return normalized_audio

# Baca file audio
input_file = "falling.mp3"
audio, sr = sf.read(input_file)

# Pastikan audio mono
if len(audio.shape) > 1:
    audio = np.mean(audio, axis=1)

# Pisahkan Bass dan Biola
bass_audio = apply_filter(audio, sr, filter_type="lowpass", cutoff=400)  # Low-pass untuk bass
violin_audio = apply_filter(audio, sr, filter_type="highpass", cutoff=2000)  # High-pass untuk biola

# Normalisasi hasil filtering
bass_normalized = normalize_audio(bass_audio)
violin_normalized = normalize_audio(violin_audio)

# Simpan hasil normalisasi ke file audio baru
sf.write("bass_normalized.wav", bass_normalized, sr)
sf.write("violin_normalized.wav", violin_normalized, sr)

print("Hasil normalisasi telah berhasil disimpan")

from IPython.display import Audio, display

# Path ke file audio
file_path_1 = 'bass_normalized.wav'
file_path_2 = 'violin_normalized.wav'
# Membuat objek Audio untuk masing-masing file
audio_1 = Audio(file_path_1)
audio_2 = Audio(file_path_2)

# Menampilkan pemutar audio untuk kedua file
display(audio_1)
display(audio_2)

"""# **Ekstraksi Fitur**

```
Jelaskan fitur apa yang ingin diekstraksi dan mengapa. Berikan statement pendukung dari artikel terkait
```
"""

import librosa
import librosa.display
import numpy as np
import pandas as pd

"""### Zero-Crossing Rate"""

# Fungsi untuk ekstraksi Zero-Crossing Rate (ZCR)
def extract_zcr(audio):
    # Ekstraksi Zero-Crossing Rate (ZCR)
    zcr = librosa.feature.zero_crossing_rate(audio)

    # Menghitung rata-rata ZCR
    zcr_mean = np.mean(zcr)

    return zcr_mean

# Menggunakan fungsi untuk bass dan biola
bass_zcr = extract_zcr(bass_normalized)
violin_zcr = extract_zcr(violin_normalized)

# Menampilkan hasil ZCR
print("Zero-Crossing Rate untuk Bass (Normalized):", bass_zcr)
print("Zero-Crossing Rate untuk Biola (Normalized):", violin_zcr)

# ZCR per frame untuk bass dan violin
bass_zcr_per_frame = librosa.feature.zero_crossing_rate(bass_normalized)[0]
violin_zcr_per_frame = librosa.feature.zero_crossing_rate(violin_normalized)[0]

# Waktu per frame
frames = range(len(bass_zcr_per_frame))
times = librosa.frames_to_time(frames, sr=sr)

# Plot ZCR
plt.figure(figsize=(12, 6))
plt.plot(times, bass_zcr_per_frame, label="Bass ZCR", color="r")
plt.plot(times, violin_zcr_per_frame, label="Violin ZCR", color="g")
plt.xlabel("Time (s)")
plt.ylabel("Zero-Crossing Rate")
plt.title("Zero-Crossing Rate (ZCR) Over Time")
plt.legend()
plt.show()

"""### Spectral Centroid

"""

# Fungsi untuk ekstraksi Spectral Centroid
def extract_spectral_centroid(audio, sr):
    # Ekstraksi Spectral Centroid
    spectral_centroid = librosa.feature.spectral_centroid(y=audio, sr=sr)

    # Menghitung rata-rata Spectral Centroid
    spectral_centroid_mean = np.mean(spectral_centroid)

    return spectral_centroid_mean

# Menggunakan fungsi untuk bass dan biola
bass_spectral_centroid = extract_spectral_centroid(bass_normalized, sr)
violin_spectral_centroid = extract_spectral_centroid(violin_normalized, sr)

# Menampilkan hasil Spectral Centroid
print("Spectral Centroid untuk Bass (Normalized):", bass_spectral_centroid)
print("Spectral Centroid untuk Biola (Normalized):", violin_spectral_centroid)

# Menghitung Spectral Centroid per frame
bass_spectral_centroid_frames = librosa.feature.spectral_centroid(y=bass_normalized, sr=sr)[0]
violin_spectral_centroid_frames = librosa.feature.spectral_centroid(y=violin_normalized, sr=sr)[0]

# Waktu untuk setiap frame
times = librosa.frames_to_time(range(len(bass_spectral_centroid_frames)), sr=sr)

# Plot Spectral Centroid untuk Bass dan Violin
plt.figure(figsize=(12, 6))

plt.plot(times, bass_spectral_centroid_frames, label="Bass Spectral Centroid", color="r")
plt.plot(times, violin_spectral_centroid_frames, label="Violin Spectral Centroid", color="g")

plt.xlabel("Time (s)")
plt.ylabel("Spectral Centroid (Hz)")
plt.title("Spectral Centroid untuk Bass dan Violin")
plt.legend()
plt.show()

"""# **Analisis**

SIGNAL-TO-NOISE-RATIO
"""

import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
import soundfile as sf

# Fungsi untuk menerapkan filter
def apply_filter(audio, sr, filter_type, cutoff):
    nyquist = sr / 2
    normalized_cutoff = cutoff / nyquist

    if filter_type == "lowpass":
        b, a = signal.butter(4, normalized_cutoff, btype="low")
    elif filter_type == "highpass":
        b, a = signal.butter(4, normalized_cutoff, btype="high")
    else:
        raise ValueError("Filter type harus 'lowpass' atau 'highpass'.")

    filtered_audio = signal.filtfilt(b, a, audio)
    return filtered_audio

# Fungsi untuk menghitung SNR
def calculate_snr(original, filtered):
    noise = original - filtered
    signal_power = np.sum(filtered ** 2)
    noise_power = np.sum(noise ** 2)
    snr = 10 * np.log10(signal_power / noise_power)
    return snr

# Fungsi untuk menghitung energi sinyal
def calculate_energy(audio):
    return np.sum(audio ** 2)

# Fungsi untuk menghitung spektrum frekuensi
def calculate_spectrum(audio, sr):
    N = len(audio)
    freq = fftfreq(N, 1 / sr)
    spectrum = np.abs(fft(audio)) / N
    return freq[:N // 2], spectrum[:N // 2]

# Baca file audio
input_file = "falling.mp3"
audio, sr = sf.read(input_file)

# Pastikan audio mono
if len(audio.shape) > 1:
    audio = np.mean(audio, axis=1)

# Pisahkan Bass dan Biola
bass_audio = apply_filter(audio, sr, filter_type="lowpass", cutoff=400)  # Low-pass untuk bass
violin_audio = apply_filter(audio, sr, filter_type="highpass", cutoff=2000)  # High-pass untuk biola

# Analisis SNR
bass_snr = calculate_snr(audio, bass_audio)
violin_snr = calculate_snr(audio, violin_audio)

# Analisis Energi
original_energy = calculate_energy(audio)
bass_energy = calculate_energy(bass_audio)
violin_energy = calculate_energy(violin_audio)

# Spektrum Frekuensi
freq, original_spectrum = calculate_spectrum(audio, sr)
_, bass_spectrum = calculate_spectrum(bass_audio, sr)
_, violin_spectrum = calculate_spectrum(violin_audio, sr)

# Cetak hasil analisis
print("=== Analisis Sinyal ===")
print(f"Energy Original: {original_energy:.2f}")
print(f"Energy Bass: {bass_energy:.2f}")
print(f"Energy Violin: {violin_energy:.2f}")
print(f"SNR Bass: {bass_snr:.2f} dB")
print(f"SNR Violin: {violin_snr:.2f} dB")

# Visualisasi Spektrum Frekuensi
plt.figure(figsize=(12, 8))

# Spektrum Sinyal Original
plt.subplot(3, 1, 1)
plt.plot(freq, original_spectrum, label="Original", color="b")
plt.title("Spektrum Frekuensi - Original")
plt.xlabel("Frekuensi (Hz)")
plt.ylabel("Amplitudo")
plt.legend()

# Spektrum Sinyal Bass
plt.subplot(3, 1, 2)
plt.plot(freq, bass_spectrum, label="Bass", color="r")
plt.title("Spektrum Frekuensi - Bass")
plt.xlabel("Frekuensi (Hz)")
plt.ylabel("Amplitudo")
plt.legend()

# Spektrum Sinyal Violin
plt.subplot(3, 1, 3)
plt.plot(freq, violin_spectrum, label="Violin", color="g")
plt.title("Spektrum Frekuensi - Violin")
plt.xlabel("Frekuensi (Hz)")
plt.ylabel("Amplitudo")
plt.legend()

plt.tight_layout()
plt.show()

"""### Sinyal sebelum dan sesudah treatment"""

# Visualisasi hasil Normalisasi
time = np.linspace(0, len(audio) / sr, num=len(audio))

plt.figure(figsize=(12, 8))
plt.subplot(3, 1, 1)
plt.plot(time, audio, label="Campuran (Bass + Biola)")
plt.legend()
plt.title("Campuran (Sebelum Treatment)")

plt.subplot(3, 1, 2)
plt.plot(time, bass_normalized, label="Bass (Low-pass Filter, Normalized)", color="r")
plt.legend()
plt.title("Bass (Normalized)")

plt.subplot(3, 1, 3)
plt.plot(time, violin_normalized, label="Biola (High-pass Filter, Normalized)", color="g")
plt.legend()
plt.title("Biola (Normalized)")

plt.tight_layout()
plt.show()